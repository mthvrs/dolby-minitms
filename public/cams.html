<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dolby Multiview</title>
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #app-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .cam-wrapper {
            background: #111;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border: 1px solid #333;
        }

        video {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        .spinner {
            border: 6px solid rgba(255, 255, 255, 0.2);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
            position: absolute;
            z-index: 10;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- HIGH VISIBILITY TIMELINE OVERLAY --- */
        .timeline-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.85); /* Much darker background */
            padding: 15px 20px;
            z-index: 100;
            backdrop-filter: blur(4px);
            border-top: 2px solid #444;
        }

        .timeline-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        /* Huge Playback Icon */
        .playback-icon {
            width: 48px;
            height: 48px;
            flex-shrink: 0;
        }
        .playback-icon.playing { color: #00e676; filter: drop-shadow(0 0 5px #00e676); }
        .playback-icon.paused { color: #ff9100; }
        .playback-icon.stopped { color: #ff1744; }

        .title-container {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        /* Huge Titles */
        .show-title {
            font-size: 32px; /* Was 14px */
            font-weight: 800;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
            text-shadow: 2px 2px 4px #000;
        }

        .cpl-title-mini {
            font-size: 18px;
            font-weight: 600;
            color: #ccc;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Thick Progress Bar */
        .progress-bar-mini {
            height: 16px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 1px solid #555;
        }

        .progress-fill-mini {
            height: 100%;
            background: #00e676;
            transition: width 0.3s linear;
        }
        .progress-fill-mini.feature { background: #2979ff; }
        .progress-fill-mini.paused { background: #ff9100; }
        .progress-fill-mini.stopped { background: #ff1744; }

        /* Huge Timers */
        .timeline-times {
            display: flex;
            justify-content: space-between;
        }

        .time-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .time-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            font-weight: 700;
        }

        .time-value {
            font-size: 28px; /* Was 11px */
            font-weight: 900;
            color: #fff;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px #000;
        }

        /* Large Badges */
        .theater-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #fff;
            border-radius: 8px;
            padding: 8px 16px;
            z-index: 100;
        }

        .badge-id {
            font-size: 24px;
            font-weight: 900;
            color: #fff;
        }

        .world-clock {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #fff;
            border-radius: 8px;
            padding: 8px 16px;
            z-index: 100;
        }

        .clock-time {
            font-size: 24px;
            font-weight: 900;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        /* Controls */
        #hover-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            opacity: 0;
            z-index: 2000;
        }
        body:hover #hover-controls { opacity: 1; }

        .control-btn {
            background: #333;
            color: #fff;
            border: 1px solid #fff;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="error-log" style="display:none; position:absolute; top:0; left:0; background:red; color:white; z-index:9999; font-size:20px; padding:10px;"></div>
    <div id="app-container"></div>

    <div id="hover-controls">
        <button class="control-btn" id="reload-btn">Recharger</button>
        <button class="control-btn" id="restart-btn">Redémarrer</button>
    </div>

    <script src="/js/api.js"></script>
    <script>
        const appContainer = document.getElementById('app-container');
        const errorLog = document.getElementById('error-log');
        const players = [];

        const logger = {
            log: (msg) => console.log(`[Cams] ${msg}`),
            error: (msg) => {
                console.error(`[Cams] ${msg}`);
                errorLog.style.display = 'block';
                errorLog.textContent = msg;
            }
        };

        const TARGET_AR = 1.777;
        const TOLERANCE = 0.10;
        const MIN_AR = TARGET_AR * (1 - TOLERANCE);
        const MAX_AR = TARGET_AR * (1 + TOLERANCE);

        document.getElementById('reload-btn').addEventListener('click', () => window.location.reload());
        document.getElementById('restart-btn').addEventListener('click', async () => {
            if (confirm('Redémarrer le serveur ?')) {
                try { await api.restartService(); setTimeout(() => window.location.reload(), 5000); }
                catch (err) { alert('Échec: ' + err.message); }
            }
        });

        class TimelineOverlay {
            constructor(container, theaterName, theaterNumber, showClock = false) {
                this.container = container;
                this.theaterName = theaterName;
                this.theaterNumber = theaterNumber;
                this.showClock = showClock;
                this.updateInterval = null;

                this.render();
                this.update();
                this.updateInterval = setInterval(() => this.update(), 2000);

                if (this.showClock) {
                    this.updateClock();
                    setInterval(() => this.updateClock(), 1000);
                }
            }

            render() {
                // Theater Badge
                const badge = document.createElement('div');
                badge.className = 'theater-badge';
                badge.innerHTML = `<div class="badge-id">S${this.theaterNumber}</div>`;
                this.container.appendChild(badge);

                // Clock
                if (this.showClock) {
                    const clock = document.createElement('div');
                    clock.className = 'world-clock';
                    clock.innerHTML = `<div class="clock-time">--:--:--</div>`;
                    this.container.appendChild(clock);
                    this.clockElement = clock.querySelector('.clock-time');
                }

                // Timeline
                const overlay = document.createElement('div');
                overlay.className = 'timeline-overlay';
                overlay.innerHTML = `
                    <div class="timeline-header">
                        <svg class="playback-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path class="icon-play" d="M8 5v14l11-7z"/>
                            <path class="icon-pause" style="display:none;" d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                            <rect class="icon-stop" style="display:none;" x="6" y="6" width="12" height="12"/>
                        </svg>
                        <div class="title-container">
                            <span class="show-title">--</span>
                            <span class="cpl-title-mini">--</span>
                        </div>
                    </div>
                    <div class="progress-bar-mini">
                        <div class="progress-fill-mini"></div>
                    </div>
                    <div class="timeline-times">
                        <div class="time-group">
                            <div class="time-label">Écoulé</div>
                            <div class="time-value time-elapsed">--:--</div>
                        </div>
                        <div class="time-group">
                            <div class="time-label">Restant</div>
                            <div class="time-value time-remaining">--:--</div>
                        </div>
                        <div class="time-group">
                            <div class="time-label">Fin</div>
                            <div class="time-value time-end">--:--</div>
                        </div>
                    </div>
                `;
                this.container.appendChild(overlay);
            }

            async update() {
                try {
                    const response = await api.getPlayback(this.theaterName);
                    if (response.success && response.playback) {
                        this.updateUI(response.playback);
                    } else {
                        this.showError();
                    }
                } catch (error) {
                    this.showError();
                }
            }

            updateUI(playback) {
                const overlay = this.container.querySelector('.timeline-overlay');
                if (!overlay) return;

                const title = overlay.querySelector('.show-title');
                const cplTitleMini = overlay.querySelector('.cpl-title-mini');
                const progress = overlay.querySelector('.progress-fill-mini');
                const elapsed = overlay.querySelector('.time-elapsed');
                const remaining = overlay.querySelector('.time-remaining');
                const end = overlay.querySelector('.time-end');
                const icon = overlay.querySelector('.playback-icon');
                const iconPlay = overlay.querySelector('.icon-play');
                const iconPause = overlay.querySelector('.icon-pause');
                const iconStop = overlay.querySelector('.icon-stop');

                const state = playback.stateInfo || 'Unknown';

                iconPlay.style.display = 'none';
                iconPause.style.display = 'none';
                iconStop.style.display = 'none';
                icon.classList.remove('playing', 'paused', 'stopped');
                progress.classList.remove('feature', 'paused', 'stopped');

                if (state === 'Play') {
                    iconPlay.style.display = 'block';
                    icon.classList.add('playing');
                    const cpl = playback.cplTitle || '';
                    if (cpl.includes('_FTR') || cpl.includes('_SHR')) {
                        progress.classList.add('feature');
                    }
                } else if (state === 'Pause') {
                    iconPause.style.display = 'block';
                    icon.classList.add('paused');
                    progress.classList.add('paused');
                } else {
                    iconStop.style.display = 'block';
                    icon.classList.add('stopped');
                    progress.classList.add('stopped');
                }

                title.textContent = playback.splTitle || 'Sans titre';

                const displayCplTitle = playback.cplTitle || '';
                cplTitleMini.textContent = displayCplTitle;
                cplTitleMini.style.display = displayCplTitle ? 'block' : 'none';

                const position = parseInt(playback.splPosition || 0);
                const duration = parseInt(playback.splDuration || 1);
                const remainingTime = Math.max(0, duration - position);
                const percentage = Math.min(100, Math.max(0, (position / duration) * 100));

                progress.style.width = `${percentage}%`;
                elapsed.textContent = this.formatTime(position);
                remaining.textContent = this.formatTime(remainingTime);

                const now = new Date();
                const endTime = new Date(now.getTime() + (remainingTime * 1000));
                end.textContent = this.formatClock(endTime);
            }

            showError() {
                // Keep simplified for space
                const overlay = this.container.querySelector('.timeline-overlay');
                if (overlay) overlay.querySelector('.show-title').textContent = 'OFFLINE';
            }

            updateClock() {
                if (this.clockElement) {
                    this.clockElement.textContent = new Date().toLocaleTimeString('fr-FR');
                }
            }

            formatTime(seconds) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = Math.floor(seconds % 60);
                if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
                return `${m}:${String(s).padStart(2, '0')}`;
            }

            formatClock(date) {
                return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            }

            destroy() {
                if (this.updateInterval) clearInterval(this.updateInterval);
            }
        }

        class WebRTCFeed {
            constructor(container, theaterSlug, theaterName, theaterNumber, isFirst) {
                this.container = container;
                this.slug = theaterSlug;
                this.pc = null;

                this.spinner = document.createElement('div');
                this.spinner.className = 'spinner';
                this.container.appendChild(this.spinner);

                this.video = document.createElement('video');
                this.video.muted = true;
                this.video.autoplay = true;
                this.video.playsInline = true;
                this.video.style.opacity = '0';
                this.video.style.transition = 'opacity 0.5s ease';
                this.container.appendChild(this.video);

                this.timeline = new TimelineOverlay(container, theaterName, theaterNumber, isFirst);

                this.video.onplaying = () => {
                    this.spinner.style.display = 'none';
                    this.video.style.opacity = '1';
                };
                this.video.onwaiting = () => this.spinner.style.display = 'block';

                this.reloadInterval = setInterval(() => this.restart(), 10 * 60 * 1000);
            }

            async start() {
                try {
                    this.spinner.style.display = 'block';
                    const whepUrl = `/api/whep/${this.slug}`;

                    this.pc = new RTCPeerConnection({ iceServers: [] });
                    this.pc.onconnectionstatechange = () => {
                        if (['failed', 'disconnected'].includes(this.pc.connectionState)) this.restart();
                    };
                    this.pc.addTransceiver('video', { direction: 'recvonly' });

                    const remoteStream = new MediaStream();
                    this.video.srcObject = remoteStream;
                    this.pc.ontrack = (ev) => ev.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));

                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);
                    await this.waitIceComplete();

                    const res = await fetch(whepUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/sdp' },
                        body: this.pc.localDescription.sdp
                    });

                    if (!res.ok) throw new Error(`WHEP Error ${res.status}`);
                    await this.pc.setRemoteDescription({ type: 'answer', sdp: await res.text() });

                } catch (e) {
                    setTimeout(() => this.restart(), 5000);
                }
            }

            waitIceComplete() {
                return new Promise(resolve => {
                    if (this.pc.iceGatheringState === 'complete') return resolve();
                    const check = () => {
                        if (this.pc.iceGatheringState === 'complete') {
                            this.pc.removeEventListener('icegatheringstatechange', check);
                            resolve();
                        }
                    };
                    this.pc.addEventListener('icegatheringstatechange', check);
                    setTimeout(resolve, 1000);
                });
            }

            restart() {
                this.video.style.opacity = '0';
                if (this.pc) { this.pc.close(); this.pc = null; }
                setTimeout(() => this.start(), 500);
            }
        }

        async function init() {
            try {
                const data = await api.getTheaters();
                const allTheaters = data.theaters || [];
                if (allTheaters.length === 0) return logger.error("Aucune salle trouvée");

                const urlParams = new URLSearchParams(window.location.search);
                const requestedIndices = [];
                for (const key of urlParams.keys()) {
                    const num = parseInt(key);
                    if (!isNaN(num) && num > 0) requestedIndices.push(num - 1);
                }

                let targets = [], targetIndices = [];
                if (requestedIndices.length > 0) {
                    requestedIndices.forEach(idx => {
                        if (idx < allTheaters.length) {
                            targets.push(allTheaters[idx]);
                            targetIndices.push(idx + 1);
                        }
                    });
                } else {
                    targets = allTheaters.slice(0, 3);
                    targetIndices = [1, 2, 3].slice(0, targets.length);
                }

                targets.forEach((t, arrIndex) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'cam-wrapper';
                    appContainer.appendChild(wrapper);
                    const feed = new WebRTCFeed(wrapper, t.slug, t.name, targetIndices[arrIndex], arrIndex === 0);
                    feed.start();
                    players.push({ wrapper, feed });
                });

                window.addEventListener('resize', calculateLayout);
                calculateLayout();
            } catch (err) { logger.error(`Erreur: ${err.message}`); }
        }

        function calculateLayout() {
            if (players.length === 0) return;
            const W = window.innerWidth, H = window.innerHeight, count = players.length;
            const hSlotW = W / count, hValid = getSquishedDimensions(hSlotW, H), hTotalArea = hValid.area * count;
            const vSlotH = H / count, vValid = getSquishedDimensions(W, vSlotH), vTotalArea = vValid.area * count;
            const bestLayout = (hTotalArea >= vTotalArea) ? 'horizontal' : 'vertical';
            const finalDims = (hTotalArea >= vTotalArea) ? hValid : vValid;

            appContainer.style.flexDirection = (bestLayout === 'horizontal') ? 'row' : 'column';
            appContainer.style.width = (bestLayout === 'horizontal') ? '100vw' : `${finalDims.w}px`;
            appContainer.style.height = (bestLayout === 'vertical') ? '100vh' : `${finalDims.h}px`;

            players.forEach(p => {
                p.wrapper.style.width = `${finalDims.w}px`;
                p.wrapper.style.height = `${finalDims.h}px`;
            });
        }

        function getSquishedDimensions(slotW, slotH) {
            const slotAR = slotW / slotH;
            if (slotAR >= MIN_AR && slotAR <= MAX_AR) return { w: slotW, h: slotH, area: slotW * slotH };
            if (slotAR < MIN_AR) { const h = slotW / MIN_AR; return { w: slotW, h: h, area: slotW * h }; }
            if (slotAR > MAX_AR) { const w = slotH * MAX_AR; return { w: w, h: slotH, area: w * slotH }; }
            return { w: slotW, h: slotH, area: 0 };
        }

        init();
    </script>
</body>
</html>