<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dolby Multiview</title>
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #app-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .cam-wrapper {
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        video {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: fill; 
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            position: absolute;
            z-index: 10;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #error-log {
            position: absolute;
            top: 0;
            left: 0;
            color: red;
            background: rgba(0,0,0,0.8);
            padding: 5px;
            display: none;
            z-index: 1000;
        }

        /* Hover Controls */
        #hover-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2000;
            pointer-events: none;
        }

        body:hover #hover-controls {
            opacity: 1;
            pointer-events: all;
        }

        .control-btn {
            background: rgba(40, 40, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: rgba(60, 60, 60, 0.95);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .control-btn svg {
            width: 18px;
            height: 18px;
        }

        /* Timeline Overlay */
        .timeline-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.9) 80%, transparent 100%);
            padding: 12px 16px 16px 16px;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .timeline-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .playback-icon {
            width: 12px;
            height: 12px;
            flex-shrink: 0;
        }

        .playback-icon.playing {
            color: #4caf50;
        }

        .playback-icon.paused {
            color: #ff9800;
        }

        .playback-icon.stopped {
            color: #f44336;
        }

        .show-title {
            font-size: 14px;
            font-weight: 700;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .title-container {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
    min-width: 0;
}

.show-title {
    font-size: 14px;
    font-weight: 700;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-shrink: 0;
}

.cpl-title-mini {
    font-size: 10px;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.5);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-style: italic;
    flex: 1;
    min-width: 0;
}


        .progress-bar-mini {
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .progress-fill-mini {
            height: 100%;
            background: #4caf50;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .progress-fill-mini.feature {
            background: #2196f3;
        }

        .progress-fill-mini.paused {
            background: #ff9800;
        }

        .progress-fill-mini.stopped {
            background: #f44336;
        }

        .timeline-times {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        .time-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .time-label {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Theater Badge - Smaller, top right */
        .theater-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            padding: 4px 8px;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .badge-id {
            font-size: 12px;
            font-weight: 700;
            color: #fff;
            text-align: center;
            line-height: 1;
        }

        /* Clock - Top left */
        .world-clock {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            padding: 4px 10px;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .clock-time {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            line-height: 1;
        }
    </style>
</head>
<body>

    <div id="error-log"></div>
    <div id="app-container"></div>

    <!-- Hover Controls -->
    <div id="hover-controls">
        <button class="control-btn" id="reload-btn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
            Recharger
        </button>
        <button class="control-btn" id="restart-btn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
                <line x1="12" y1="2" x2="12" y2="12"></line>
            </svg>
            Redémarrer
        </button>
    </div>

    <script src="/js/api.js"></script>
    <script>
        const appContainer = document.getElementById('app-container');
        const errorLog = document.getElementById('error-log');
        const players = [];
        
        const logger = {
            log: (msg) => console.log(`[Cams] ${msg}`),
            error: (msg) => {
                console.error(`[Cams] ${msg}`);
                errorLog.style.display = 'block';
                errorLog.textContent = msg;
            }
        };

        const TARGET_AR = 1.777;
        const TOLERANCE = 0.10;  
        const MIN_AR = TARGET_AR * (1 - TOLERANCE);
        const MAX_AR = TARGET_AR * (1 + TOLERANCE);

        // Setup controls
        document.getElementById('reload-btn').addEventListener('click', () => {
            window.location.reload();
        });

        document.getElementById('restart-btn').addEventListener('click', async () => {
            if (confirm('Redémarrer le serveur ?')) {
                try {
                    await api.restartService();
                    setTimeout(() => window.location.reload(), 5000);
                } catch (err) {
                    alert('Échec du redémarrage : ' + err.message);
                }
            }
        });

        // Timeline Overlay Component - EXACTLY like playbackTimeline.js
        class TimelineOverlay {
            constructor(container, theaterName, theaterNumber, showClock = false) {
                this.container = container;
                this.theaterName = theaterName; // Use NAME not slug, like the main component
                this.theaterNumber = theaterNumber;
                this.showClock = showClock;
                this.updateInterval = null;
                
                this.render();
                this.update();
                this.updateInterval = setInterval(() => this.update(), 2000);
                
                if (this.showClock) {
                    this.updateClock();
                    setInterval(() => this.updateClock(), 1000);
                }
            }

            render() {
    // Theater badge (top right)
    const badge = document.createElement('div');
    badge.className = 'theater-badge';
    badge.innerHTML = `<div class="badge-id">S${this.theaterNumber}</div>`;
    this.container.appendChild(badge);

    // World clock (top left, only if showClock is true)
    if (this.showClock) {
        const clock = document.createElement('div');
        clock.className = 'world-clock';
        clock.innerHTML = `<div class="clock-time">--:--:--</div>`;
        this.container.appendChild(clock);
        this.clockElement = clock.querySelector('.clock-time');
    }

    // Timeline overlay
    const overlay = document.createElement('div');
    overlay.className = 'timeline-overlay';
    overlay.innerHTML = `
        <div class="timeline-header">
            <svg class="playback-icon" viewBox="0 0 24 24" fill="currentColor">
                <path class="icon-play" d="M8 5v14l11-7z"/>
                <path class="icon-pause" style="display:none;" d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                <rect class="icon-stop" style="display:none;" x="6" y="6" width="12" height="12"/>
            </svg>
            <div class="title-container">
                <span class="show-title">--</span>
                <span class="cpl-title-mini">--</span>
            </div>
        </div>
        <div class="progress-bar-mini">
            <div class="progress-fill-mini"></div>
        </div>
        <div class="timeline-times">
            <div class="time-group">
                <div class="time-label">Écoulé</div>
                <div class="time-value time-elapsed">--:--</div>
            </div>
            <div class="time-group">
                <div class="time-label">Restant</div>
                <div class="time-value time-remaining">--:--</div>
            </div>
            <div class="time-group">
                <div class="time-label">Fin</div>
                <div class="time-value time-end">--:--</div>
            </div>
        </div>
    `;
    this.container.appendChild(overlay);
}
            async update() {
                try {
                    // Use theaterName like the main component does
                    const response = await api.getPlayback(this.theaterName);
                    
                    if (response.success && response.playback) {
                        this.updateUI(response.playback);
                    } else {
                        this.showError();
                    }
                } catch (error) {
                    console.error('Timeline error:', error);
                    this.showError();
                }
            }
updateUI(playback) {
    const overlay = this.container.querySelector('.timeline-overlay');
    if (!overlay) return;

    const title = overlay.querySelector('.show-title');
    const cplTitleMini = overlay.querySelector('.cpl-title-mini');
    const progress = overlay.querySelector('.progress-fill-mini');
    const elapsed = overlay.querySelector('.time-elapsed');
    const remaining = overlay.querySelector('.time-remaining');
    const end = overlay.querySelector('.time-end');
    const icon = overlay.querySelector('.playback-icon');
    const iconPlay = overlay.querySelector('.icon-play');
    const iconPause = overlay.querySelector('.icon-pause');
    const iconStop = overlay.querySelector('.icon-stop');

    const state = playback.stateInfo || 'Unknown';
    
    // Update icon
    iconPlay.style.display = 'none';
    iconPause.style.display = 'none';
    iconStop.style.display = 'none';
    
    // Reset SVG classes using classList (not className)
    icon.classList.remove('playing', 'paused', 'stopped');
    progress.classList.remove('feature', 'paused', 'stopped');
    
    if (state === 'Play') {
        iconPlay.style.display = 'block';
        icon.classList.add('playing');
        
        const cpl = playback.cplTitle || '';
        if (cpl.includes('_FTR') || cpl.includes('_SHR')) {
            progress.classList.add('feature');
        }
    } else if (state === 'Pause') {
        iconPause.style.display = 'block';
        icon.classList.add('paused');
        progress.classList.add('paused');
    } else {
        iconStop.style.display = 'block';
        icon.classList.add('stopped');
        progress.classList.add('stopped');
    }

    // Update SPL title
    const displayTitle = playback.splTitle || 'Sans titre';
    title.textContent = displayTitle;
    title.title = displayTitle;

    // Update CPL title (small and grey)
    const displayCplTitle = playback.cplTitle || '';
    if (displayCplTitle) {
        cplTitleMini.textContent = displayCplTitle;
        cplTitleMini.title = displayCplTitle;
        cplTitleMini.style.display = 'inline';
    } else {
        cplTitleMini.style.display = 'none';
    }

    // Calculate times
    const position = parseInt(playback.splPosition || 0);
    const duration = parseInt(playback.splDuration || 1);
    const remainingTime = Math.max(0, duration - position);
    const percentage = Math.min(100, Math.max(0, (position / duration) * 100));

    // Update progress
    progress.style.width = `${percentage}%`;

    // Update times
    elapsed.textContent = this.formatTime(position);
    remaining.textContent = this.formatTime(remainingTime);
    
    const now = new Date();
    const endTime = new Date(now.getTime() + (remainingTime * 1000));
    end.textContent = this.formatClock(endTime);
}

            showError() {
                const overlay = this.container.querySelector('.timeline-overlay');
                if (!overlay) return;

                const title = overlay.querySelector('.show-title');
                const progress = overlay.querySelector('.progress-fill-mini');
                const elapsed = overlay.querySelector('.time-elapsed');
                const remaining = overlay.querySelector('.time-remaining');
                const end = overlay.querySelector('.time-end');
                
                if (title) title.textContent = 'Erreur';
                if (progress) progress.style.width = '0%';
                if (elapsed) elapsed.textContent = '--:--';
                if (remaining) remaining.textContent = '--:--';
                if (end) end.textContent = '--:--';
            }

            updateClock() {
                if (this.clockElement) {
                    const now = new Date();
                    this.clockElement.textContent = now.toLocaleTimeString('fr-FR');
                }
            }

            formatTime(seconds) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = Math.floor(seconds % 60);
                
                if (h > 0) {
                    return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
                } else {
                    return `${m}:${String(s).padStart(2, '0')}`;
                }
            }

            formatClock(date) {
                return date.toLocaleTimeString('fr-FR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
            }

            destroy() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                }
            }
        }

        // --- WebRTC Player Class ---
        class WebRTCFeed {
            constructor(container, theaterSlug, theaterName, theaterNumber, isFirst) {
                this.container = container;
                this.slug = theaterSlug;
                this.pc = null;
                
                this.spinner = document.createElement('div');
                this.spinner.className = 'spinner';
                this.container.appendChild(this.spinner);

                this.video = document.createElement('video');
                this.video.muted = true;
                this.video.autoplay = true;
                this.video.playsInline = true;
                this.video.style.opacity = '0'; 
                this.video.style.transition = 'opacity 0.5s ease';
                this.container.appendChild(this.video);

                // Timeline Overlay - pass NAME not slug
                this.timeline = new TimelineOverlay(container, theaterName, theaterNumber, isFirst);

                this.video.onplaying = () => {
                    this.spinner.style.display = 'none';
                    this.video.style.opacity = '1';
                };

                this.video.onwaiting = () => {
                    this.spinner.style.display = 'block';
                };
                
                this.reloadInterval = setInterval(() => {
                    logger.log(`[${this.slug}] Scheduled reload...`);
                    this.restart();
                }, 10 * 60 * 1000);
            }

            async start() {
                try {
                    this.spinner.style.display = 'block';
                    const whepUrl = `/api/whep/${this.slug}`;
                    logger.log(`Starting WebRTC for ${this.slug}`);

                    this.pc = new RTCPeerConnection({ iceServers: [] });
                    
                    this.pc.onconnectionstatechange = () => {
                        const state = this.pc.connectionState;
                        logger.log(`[${this.slug}] Connection State: ${state}`);
                        if (state === 'failed' || state === 'disconnected') {
                            logger.log(`[${this.slug}] Connection failed. Restarting...`);
                            this.restart();
                        }
                    };

                    this.pc.addTransceiver('video', { direction: 'recvonly' });
                    
                    const remoteStream = new MediaStream();
                    this.video.srcObject = remoteStream;

                    this.pc.ontrack = (ev) => {
                        ev.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
                    };

                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);
                    await this.waitIceComplete();

                    const res = await fetch(whepUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/sdp' },
                        body: this.pc.localDescription.sdp
                    });

                    if (!res.ok) throw new Error(`WHEP Error ${res.status}`);
                    
                    const answer = await res.text();
                    await this.pc.setRemoteDescription({ type: 'answer', sdp: answer });
                    
                } catch (e) {
                    logger.error(`Stream Error (${this.slug}): ${e.message}`);
                    setTimeout(() => this.restart(), 5000);
                }
            }

            waitIceComplete() {
                return new Promise(resolve => {
                    if (this.pc.iceGatheringState === 'complete') return resolve();
                    const check = () => {
                        if (this.pc.iceGatheringState === 'complete') {
                            this.pc.removeEventListener('icegatheringstatechange', check);
                            resolve();
                        }
                    };
                    this.pc.addEventListener('icegatheringstatechange', check);
                    setTimeout(resolve, 1000);
                });
            }

            restart() {
                this.video.style.opacity = '0';
                this.spinner.style.display = 'block';
                
                if (this.pc) {
                    this.pc.close();
                    this.pc = null;
                }
                setTimeout(() => this.start(), 500);
            }
        }

        // --- Main Logic ---
        async function init() {
            try {
                const data = await api.getTheaters();
                const allTheaters = data.theaters || [];
                
                if (allTheaters.length === 0) return logger.error("Aucune salle trouvée");

                const urlParams = new URLSearchParams(window.location.search);
                const requestedIndices = [];
                
                for (const key of urlParams.keys()) {
                    const num = parseInt(key);
                    if (!isNaN(num) && num > 0) {
                        requestedIndices.push(num - 1);
                    }
                }

                let targets = [];
                let targetIndices = [];
                
                if (requestedIndices.length > 0) {
                    requestedIndices.forEach(idx => {
                        if (idx < allTheaters.length) {
                            targets.push(allTheaters[idx]);
                            targetIndices.push(idx + 1);
                        }
                    });
                    
                    if (targets.length === 0) {
                        return logger.error(`Salles ${requestedIndices.map(i=>i+1).join(', ')} introuvables.`);
                    }
                    logger.log(`Affichage des salles: ${targets.map(t => t.name).join(', ')}`);
                } else {
                    targets = allTheaters.slice(0, 3);
                    targetIndices = [1, 2, 3].slice(0, targets.length);
                    logger.log(`Affichage multiview par défaut (3 premières salles)`);
                }

                // Create players - pass BOTH slug (for video) and name (for API)
                targets.forEach((t, arrIndex) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'cam-wrapper';
                    appContainer.appendChild(wrapper);

                    const theaterNumber = targetIndices[arrIndex];
                    const feed = new WebRTCFeed(wrapper, t.slug, t.name, theaterNumber, arrIndex === 0);
                    feed.start();

                    players.push({ wrapper, feed });
                });

                window.addEventListener('resize', calculateLayout);
                calculateLayout();

            } catch (err) {
                logger.error(`Erreur d'initialisation: ${err.message}`);
            }
        }

        function calculateLayout() {
            if (players.length === 0) return;

            const W = window.innerWidth;
            const H = window.innerHeight;
            const count = players.length;

            const hSlotW = W / count;
            const hValid = getSquishedDimensions(hSlotW, H);
            const hTotalArea = hValid.area * count;

            const vSlotH = H / count;
            const vValid = getSquishedDimensions(W, vSlotH);
            const vTotalArea = vValid.area * count;

            let bestLayout = (hTotalArea >= vTotalArea) ? 'horizontal' : 'vertical';
            let finalDims = (hTotalArea >= vTotalArea) ? hValid : vValid;

            appContainer.style.flexDirection = (bestLayout === 'horizontal') ? 'row' : 'column';
            appContainer.style.width = (bestLayout === 'horizontal') ? '100vw' : `${finalDims.w}px`;
            appContainer.style.height = (bestLayout === 'vertical') ? '100vh' : `${finalDims.h}px`;

            players.forEach(p => {
                p.wrapper.style.width = `${finalDims.w}px`;
                p.wrapper.style.height = `${finalDims.h}px`;
            });
        }

        function getSquishedDimensions(slotW, slotH) {
            const slotAR = slotW / slotH;
            
            if (slotAR >= MIN_AR && slotAR <= MAX_AR) {
                return { w: slotW, h: slotH, area: slotW * slotH };
            }
            if (slotAR < MIN_AR) { 
                const h = slotW / MIN_AR; 
                return { w: slotW, h: h, area: slotW * h }; 
            }
            if (slotAR > MAX_AR) { 
                const w = slotH * MAX_AR; 
                return { w: w, h: slotH, area: w * slotH }; 
            }
            return { w: slotW, h: slotH, area: 0 };
        }

        init();
    </script>
</body>
</html>
